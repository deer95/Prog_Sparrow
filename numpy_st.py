import numpy as np

a = np.arange(100)

# элементы в матрице с индексами заменятся на 99. Неточно!
N = [4, 6, 7, 1, 4, 5]
a[np.arange(N), y]= 99
#диагональ матрицы
print(a[range(10), range(10)])

# ФОРМИРОВАТЬ МАССИВ
b = a.reshape(20, 5)
# при reshape() не происходит копирования массива, изменяется и исходный, и конечный массив
# узнаем источник массива B
the_base = b.base is a
# меняем форму исходного массива
a.shape(2, 10, 5)
'''
Чтобы менять форму массива более изощренно:
concatenate
stack
split
pad
clip
ravel
transpose
np.newaxis
'''


# ИТЕРИРОВАНИЕ
a = np.arange(24).reshape(2, 3, 4)

# по верхней оси
for matrix in a:
    print(matrix)
# сплошное итерирование
for elt in a.flat:
    print(elt)
# flat - это атрибут-итератор, который идет последовательно по всем элементам массива


# ПЕЧАТЬ МАССИВА
# если массив большой, то можно установить, сколько значений по краям показывать
# или показывать вообще все, как на строке ниже
a.set_setprintoptions(threshold = np.nan)


# КОПИИ И ПРЕДСТАВЛЕНИЯ
# 1. никаких копий. Новый объект не создается
a = np.arange(12)
b = a
is_eqaul = b is a       # is True

# 2. поверхностная копия. Можно поменять только форму массива, а данные остаются теми же на два массива
c = a.view()
# с - новый объект массива
is_equal_as_np_object = a is c   # is False
is_equal_as_data_in_memory = c.base is a    # is True

c.shape = 2, 6      # c != a
c[0, 0] = 2018      # меняются данные в А и С
c = a.reshape((2, 2, 3))        # возвращает представвление
# срезы почти всегда тоже представления
a = np.zeros((10, 10), dtype=int)
s = a[:, 1:3]
# срезы остаются представлением только тогда, когда они не очень сложные
t = a[:, [1,2,3]]
t[:] = 99       # при этом А не поменяется

# 3. глубокая копия
d = a.copy()
# d is a        is False
# d.base is a       is False





